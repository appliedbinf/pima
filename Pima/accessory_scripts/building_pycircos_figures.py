from __future__ import annotations

import os
from collections import defaultdict

from pycircos import Garc, Gcircle
import matplotlib.pyplot as plt
import matplotlib.colors as colors
import matplotlib.patches as mpatches



class BuildCircosPlots:
    """Build circos plot for genome alignment, coverage data, and gene annotations

    Expects inputs that are generated by the main 'pima.py' pipeline. Creates a png image \
    for each genetic element within the reference genome provided to pima.

    Typical usage example:
        circos_elem = BuildCircosPlots(ge_name=ge_name, 
                                    ge_size=int(ge_size),
                                    aln_file=aln_file,
                                    cov_file=cov_file,
                                    illumina_cov_file=illumina_cov_file,
                                    gene_file=gene_file,
                                    outdir=<Path>)
        circos_fig = circos_elem.main()
        circos_fig.save(file_name=f"{Path}/{ge_name}", format="png", dpi=300)
    
    """
    def __init__(self, ge_name: str, ge_size: int, aln_file: str | None, outdir:str, cov_file: str | None,illumina_cov_file: str | None, gene_file: str | None, legend = True) -> None:
        """Initializing data to build the circos plots

        Args:
            ge_name (str): Name of the genetic element being plotted (chromosome, plasmid, etc..)
            ge_size (int): Length of the genetic element (bp)
            aln_file (str, optional): Path to the genome:genome alignment file, generated by dnadiff & filtered
            outdir (str): Path to save the results
            cov_file (str, optional): Path to the ONT coverage data, filtered for columns "sequenceID\tpos\tcoverage (cut -f1,2,4 from mpileup). Defaults to None | str.
            illumina_cov_file (str, optional): Path to the illumina coverage data, filtered for columns "sequenceID\tpos\tcoverage (cut -f1,2,4 from mpileup. Defaults to None | str.
            gene_file (str, optional): Path to a bed file indicating which genes to draw on the reference genome map. Defaults to None | str.
            legend (bool, optional): Generate a legend (T / F)
        Returns:
            None
        """

        self.ge_name = ge_name
        self.ge_size = ge_size
        self.aln_file = aln_file
        self.outdir = outdir
        self.cov_file = cov_file
        self.illumina_cov_file = illumina_cov_file
        self.gene_file = gene_file
        self.legend = legend

        

        #instantiate dictionaries that contain data for each of the plotting steps
        self.aln_dict = defaultdict(dict)
        self.n_colors = defaultdict(dict)
        self.cov_dict = defaultdict(dict)
        self.illumina_cov_dict = defaultdict(dict)
        self.ge_circle = Gcircle()

    def build_reference_genome(self) -> None:
        """Generates the reference genome backbone

        Returns:
            None
        """
        elem_arc = Garc(arc_id = self.ge_name,
                        size = self.ge_size,
                        raxis_range = [600, 700],
                        facecolor="#FFFFFF",
                        linewidth=1,
                        edgecolor="#000000",
                        label_visible=False,
                        interspace=0
                        )
        self.ge_circle.add_garc(elem_arc)
        self.ge_circle.set_garcs()

    def add_tickmarks(self) -> None:
        """Places logical tick marks indicating genome element size

        Returns:
            None
        """
        # use different spacing for the chromosome vs plasmids
        if self.ge_size > 2000000:
            tick_major_positions = list(range(0,self.ge_size,1000000))
            tick_minor_positions = list(range(0,self.ge_size,200000))
            tick_labels = [f"{int(i/1000000)} Mb" for i in tick_major_positions]
        else:
            tick_major_positions = list(range(0, self.ge_size,20000))
            tick_minor_positions = list(range(0,self.ge_size,5000))
            tick_labels = [f"{int(i/1000)} kb" for i in tick_major_positions]

        #major tick marks with labels
        self.ge_circle.tickplot(garc_id=self.ge_name,
                        raxis_range=(550,600),
                        tickpositions=tick_major_positions,
                        tickdirection="inner",
                        ticklabels=tick_labels,
                        ticklabelmargin=10
                        )
        # minor tick marks
        self.ge_circle.tickplot(garc_id=self.ge_name,
                        raxis_range=(550,600),
                        tickpositions=tick_minor_positions,
                        tickdirection="inner",
                        tickwidth=0.5
                        )

    def build_alignment_plot(self) -> None:
        """Build garcs indicating which portions of the query genome align to the reference genome backbone

        Can show up to 20 colors representing query genome contigs before repeating. 
        """
        if self.aln_file is None:
            return

        self.aln_dict["start"] = []
        self.aln_dict["len"] = []
        self.aln_dict["contig"] = []
        self.aln_dict["color"] = []
        
        with open(self.aln_file,"r") as fin:
            for line in fin:
                ref_name, ref_start, ref_end, qname = line.rstrip().split("\t")
                aln_len = int(ref_end) - int(ref_start)
                
                self.aln_dict["start"].append(int(ref_start))
                self.aln_dict["len"].append(int(aln_len))
                self.aln_dict["contig"].append(qname)

        ## Generate different colors for different chromosomes
        qual_colors_20 = plt.colormaps['tab20']
        uniq_contigs = [*set(self.aln_dict['contig'])]
        self.n_colors['n_contigs'] = len(uniq_contigs)
        self.n_colors['contig_names'] = uniq_contigs
        self.n_colors['colors'] = []
        for i, contig_id in enumerate(uniq_contigs):
            self.n_colors['colors'].append(colors.rgb2hex(qual_colors_20(i)))

        ## Add colors to the alignment dictionary
        for contig_name in self.aln_dict['contig']:
            i = self.n_colors['contig_names'].index(contig_name)
            self.aln_dict['color'].append(self.n_colors['colors'][i])

        ## build the barplots that map the genome aligment onto the chromosome plot
        if not len(self.aln_dict['start']) == 0:
            self.ge_circle.barplot(self.ge_name, 
                        data = [1]*len(self.aln_dict["start"]), 
                        positions=self.aln_dict["start"],
                        width=self.aln_dict["len"],
                        raxis_range=[600,700],
                        facecolor=self.aln_dict["color"],
                        linewidth=0)
            
    def build_coverage_plot(self) -> None:
        """Generates a garc fillplot of the ONT coverage data"""
        if self.cov_file is None:
            return
        
        self.cov_dict["pos"] = []
        self.cov_dict["cov"] = []
        with open(self.cov_file, 'r') as fin:
            for line in fin:
                element, pos, cov, = line.rstrip().rsplit("\t")
                self.cov_dict["pos"].append(int(pos))
                self.cov_dict["cov"].append(int(cov))

        if not len(self.cov_dict['pos']) == 0:
            self.ge_circle.fillplot(self.ge_name, 
                        data = self.cov_dict["cov"], 
                        positions=self.cov_dict["pos"],
                        raxis_range=[701,850],
                        base_value=0,
                        rlim=(0,max(self.cov_dict["cov"])),
                        facecolor="#808080")

    def build_illumina_coverage_plot(self) -> None:
        """Generates a garc fillplot of the Illumina coverage data"""
        if self.illumina_cov_file is None:
            return
        
        self.illumina_cov_dict["pos"] = []
        self.illumina_cov_dict["cov"] = []
        with open(self.illumina_cov_file, 'r') as fin:
            for line in fin:
                element, pos, cov, = line.rstrip().rsplit("\t")
                self.illumina_cov_dict["pos"].append(int(pos))
                self.illumina_cov_dict["cov"].append(int(cov))

        if not len(self.illumina_cov_dict['pos']) == 0:
            self.ge_circle.fillplot(self.ge_name, 
                        data = self.illumina_cov_dict["cov"], 
                        positions=self.illumina_cov_dict["pos"],
                        raxis_range=[851,1000],
                        base_value=0,
                        rlim=(0,max(self.illumina_cov_dict["cov"])),
                        facecolor="#808080")

    def add_cov_labels(self) -> None:
        """Generates the middle text indicating genetic element name (from the reference) and coverage statistics"""
        self.ge_circle.ax.text(0.5,0.53,f"{self.ge_name}", fontsize=20,
                               transform=self.ge_circle.ax.transAxes,
                               ha='center')
        
        if (self.cov_file is not None and len(self.cov_dict['cov']) != 0):
            min_cov = min(self.cov_dict['cov'])
            max_cov = max(self.cov_dict['cov'])
            avg_cov = round(sum(self.cov_dict['cov']) / len(self.cov_dict['cov']), 1)
            self.ge_circle.ax.text(0.5,0.45,
                               f"ONT Average Coverage: {avg_cov}\nONT Minimum Coverage: {min_cov}\nONT Maximum Coverage: {max_cov}",
                               fontsize=10,
                               transform=self.ge_circle.ax.transAxes,
                               ha='center')
        if (self.illumina_cov_file is not None and len(self.illumina_cov_dict['cov']) != 0):
            illumina_min_cov = min(self.illumina_cov_dict['cov'])
            illumina_max_cov = max(self.illumina_cov_dict['cov'])
            illumina_avg_cov = round(sum(self.illumina_cov_dict['cov']) / len(self.illumina_cov_dict['cov']), 1)
            self.ge_circle.ax.text(0.5,0.37,
                               f"Illumina Average Coverage: {illumina_avg_cov}\n" + 
                               f"Illumina Minimum Coverage: {illumina_min_cov}\n" + 
                               f"Illumina Maximum Coverage: {illumina_max_cov}",
                               fontsize=10,
                               transform=self.ge_circle.ax.transAxes,
                               ha='center')

    def add_gene_loc(self) -> None:
        """Draws gene annotations onto the reference backbone given a bed file"""
        if self.gene_file is None:
            return
        
        gene_dict = defaultdict(dict)
        label_pos = []
        label_id = []
        gene_dict['pos'] = []
        gene_dict['width'] = []
        with open(self.gene_file) as fin:
            for line in fin:
                elem_name, start, stop, gene_name = line.rstrip().split("\t")
                if elem_name == self.ge_name:
                    start = int(start)
                    width = int(stop)-start-1
                    gene_dict['pos'].append(start)
                    gene_dict['width'].append(width)
                    label_pos.append(int(round(start + (width / 2),0)))
                    label_id.append(f"$\\it\u007b{gene_name}\u007d$")

        if len(gene_dict['pos']) > 0:
            self.ge_circle.barplot(garc_id = self.ge_name,
                            data=[1]*len(gene_dict['pos']),
                            positions=gene_dict['pos'],
                            width=gene_dict['width'],
                            raxis_range=(600,700),
                            facecolor="#FF000040",
                            edgecolor="#000000",
                            linewidth=1)
        
            self.ge_circle.tickplot(garc_id = self.ge_name,
                                tickpositions=label_pos,
                                ticklabels=label_id,
                                tickdirection="inner",
                                tickcolor="#FF0000",
                                ticklabelcolor="#FF0000",
                                ticklabelmargin=20)
            
    def build_legend(self) -> None:
        """Generates the legend showing: genome:genome alignments, contig IDs, and the coverage data"""
        leg = []
        leg.append(mpatches.Patch(facecolor = "#FFFFFF", edgecolor= "#000000", label = "No alignment to reference"))
        #leg.append(mpatches.Patch(facecolor = "#1f77b4", label = ">98%% sequence alignment to $\it{Ba}$ Ames Ancestor"))
        #leg.append(mpatches.Patch(facecolor = "#808080", label = 'Inner: ONT Coverage across $\it{Ba}$ Ames Ancestor'))
        #leg.append(mpatches.Patch(facecolor = "#808080", label = "Outer: Illumina Coverage across $\it{Ba}$ Ames Ancestor"))

        if not len(self.n_colors) == 0:
            for i, contig in enumerate(self.n_colors['contig_names']):
                leg_patch = mpatches.Patch(color = self.n_colors['colors'][i], label = contig)
                leg.append(leg_patch)

        #both illumina and ONT coverage data
        if len(self.cov_dict['cov']) != 0 and len(self.illumina_cov_dict['cov']) != 0:
            leg.append(mpatches.Patch(facecolor = "#808080", label = 'Inner: ONT Coverage across reference'))
            leg.append(mpatches.Patch(facecolor = "#808080", label = "Outer: Illumina Coverage across reference"))

        # only ONT
        elif len(self.cov_dict['cov']) != 0:
            leg.append(mpatches.Patch(facecolor = "#808080", label = 'ONT Coverage across reference'))

        # only Illumina
        elif len(self.cov_dict['cov']) == 0 and len(self.illumina_cov_dict['cov']) != 0:
            leg.append(mpatches.Patch(facecolor = "#808080", label = 'Illumina Coverage across reference'))
            
        #self.ge_circle.ax.legend(handles=leg, prop={'size': 9}, bbox_to_anchor=(0.18,0.11)) #loc=3
        self.ge_circle.figure.legend(handles=leg, prop={'size': 9}, loc=3)

    def main(self) -> Gcircle:
        """Executes each method in the BuildCircosPlots class depending on data inputs

        Returns:
            Gcircle: A class object containing all the data to be visualized
        """
        self.build_reference_genome()
        self.add_tickmarks()
        self.build_alignment_plot()
        self.build_coverage_plot()
        self.build_illumina_coverage_plot()
        self.add_cov_labels()
        self.add_gene_loc()
        if self.legend:
            self.build_legend()
        return self.ge_circle


if __name__ == "__main__":
    import argparse
    import sys
    import re
    import subprocess

    parser = argparse.ArgumentParser()
    # add input for reference genome only
    parser.add_argument("-i", "--input_dir", help="Output directory generated by a previous pima (v1.4 or higher) run")
    parser.add_argument("-r", "--reference_genome", help="Input reference genome to draw specific gene locations on")
    parser.add_argument("-o", "--output_dir", help="Where to save the results")
    parser.add_argument("-g", "--gene_file", required=False,
                        help="bed file format with the location of the genes to draw in the reference coordinates format")
    parser.add_argument("--image_format", help = "The output image type, support is determined by the matplotlib backend: 'png', 'pdf', 'ps', 'eps', and 'svg' should all work",
                        required = False, default='png')

    args = parser.parse_args()

    if args.input_dir and args.reference_genome:
        print("Please specify either -i OR -r. These are mutually exclusive flags")
        sys.exit(0)
    

    outdir = args.output_dir
    if not os.path.exists(outdir):
        os.makedirs(outdir)
        

    def validate_files(var_fp):
        if not os.path.isfile(var_fp):
            var_fp = None
            return var_fp
        else:
            return var_fp

    ## Building circos plots to represent specific gene functions on a reference genome
    if args.reference_genome:
        reference_genome = args.reference_genome
        reference_sizes = os.path.join(outdir, "reference.sizes")

        # build the reference.sizes file
        command = ' '.join(['faidx -i chromsizes', reference_genome, ' | sort -k 1,1 -k 2,2n'])
        reference_sizes = [x for x in re.split(r'\n', subprocess.check_output(command, shell = True).decode('utf-8')) if x] 

        # add the gene file
        gene_file = args.gene_file

        ## Manually constructing the Gcircle object because I want to modify some of the steps
        for element in reference_sizes:
            ge_name, ge_size = element.rsplit()

            circos_elem = BuildCircosPlots(ge_name=ge_name, 
                                            aln_file=None,
                                            cov_file = None,
                                            illumina_cov_file = None,
                                            ge_size=int(ge_size),
                                            gene_file=gene_file,
                                            legend=False,
                                            outdir=None)
            circos_fig = circos_elem.main()

            # a hack - but we want the reference genome to be filled for these figures instead of blank
            circos_elem.ge_circle.barplot(ge_name,
                                          data = [1],
                                          positions=[int(1)],
                                          width=[int(ge_size)-1],
                                          raxis_range=[600,700],
                                          facecolor="#1f77b4",
                                          linewidth=0)
            circos_fig.save(file_name=f"{outdir}/{ge_name}", format=args.image_format , dpi=300)

    ## Building custom pima plots
    else:
        with open(f"{args.input_dir}/insertions/reference.sizes", "r") as fin:
            for line in fin:
                ge_name, ge_size = line.rstrip().rsplit()
                aln_file = f"{args.input_dir}/circos/{ge_name}/alignment.txt"
                cov_file = f"{args.input_dir}/circos/{ge_name}/coverage.mpileup"
                illumina_cov_file = f"{args.input_dir}/circos/{ge_name}/illumina_coverage.mpileup"
                gene_file = args.gene_file
                

                aln_file = validate_files(aln_file)
                cov_file = validate_files(cov_file)
                illumina_cov_file = validate_files(illumina_cov_file)

                circos_elem = BuildCircosPlots(ge_name=ge_name, 
                                                ge_size=int(ge_size),
                                                aln_file=aln_file,
                                                cov_file=cov_file,
                                                illumina_cov_file=illumina_cov_file,
                                                gene_file=gene_file,
                                                outdir=None)
                
                circos_fig = circos_elem.main()

                circos_fig.save(file_name=f"{outdir}/{ge_name}", format="png" , dpi=300)

"""
    for dir in os.scandir("../pima_downsample_ont/"):
        if dir.is_dir():
            dirname = os.path.basename(dir)
            with open(f"{dir.path}/insertions/reference.sizes", "r") as fin:
                for line in fin:
                    ge_name, ge_size = line.rstrip().rsplit()
                    aln_file = f"{dir.path}/circos/{ge_name}/alignment.txt"
                    cov_file = f"{dir.path}/circos/{ge_name}/coverage.mpileup"
                    illumina_cov_file = f"{dir.path}/circos/{ge_name}/illumina_coverage.mpileup"
                    gene_file = "/scicomp/home-pure/tsz0/Projects/devPima/MergedPima/data/ba_virulence_genes.bed"
                    #outdir = f"{dir.path}/pima_out/20230308_Minion_TM_01/Sterne-CLR1-2/circos/{ge_name}"
                    circos_elem = BuildCircosPlots(ge_name=ge_name, 
                                                    ge_size=int(ge_size),
                                                    aln_file=aln_file,
                                                    cov_file=cov_file,
                                                    illumina_cov_file=illumina_cov_file,
                                                    gene_file=gene_file,
                                                    outdir=None)
                    circos_fig = circos_elem.main()
                    circos_fig.save(file_name=f"{dirname}_{ge_name}", format="png" , dpi=300)
"""